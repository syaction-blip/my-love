<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Valentine Proposal üíñ</title>

  <style>
    /* =========================
       Base + Background (Animated Gradient)
       ========================= */
    :root {
      --glass-bg: rgba(255, 255, 255, 0.12);
      --glass-border: rgba(255, 255, 255, 0.25);
      --text: rgba(255, 255, 255, 0.92);
      --muted: rgba(255, 255, 255, 0.75);
      --shadow: rgba(0, 0, 0, 0.25);

      --yes: #ff4d8d;
      --yes2: #ff2d55;

      --no: rgba(255, 255, 255, 0.12);
      --no-border: rgba(255, 255, 255, 0.30);

      --romantic-overlay: rgba(255, 50, 140, 0.12);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
      color: var(--text);
      overflow: hidden; /* Keep runaway button within viewport cleanly */
    }

    /* Background layer */
    .bg {
      position: fixed;
      inset: 0;
      background: radial-gradient(1200px 800px at 20% 20%, rgba(255, 80, 180, 0.35), transparent 55%),
                  radial-gradient(1000px 700px at 80% 30%, rgba(90, 200, 255, 0.28), transparent 55%),
                  radial-gradient(900px 700px at 50% 80%, rgba(255, 210, 120, 0.20), transparent 55%),
                  linear-gradient(120deg, #0b1020, #19103a, #1a2a4a);
      background-size: 200% 200%;
      animation: bgShift 10s ease-in-out infinite;
      filter: saturate(1.05);
    }

    @keyframes bgShift {
      0% { background-position: 0% 20%; }
      50% { background-position: 100% 80%; }
      100% { background-position: 0% 20%; }
    }

    /* Romantic mode overlay + subtle sparkle */
    .romantic {
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 900ms ease;
      background:
        radial-gradient(700px 500px at 30% 25%, rgba(255, 60, 170, 0.26), transparent 60%),
        radial-gradient(700px 500px at 70% 35%, rgba(255, 120, 160, 0.18), transparent 60%),
        radial-gradient(900px 700px at 50% 90%, rgba(255, 230, 200, 0.12), transparent 65%),
        linear-gradient(180deg, rgba(255, 40, 120, 0.06), rgba(255, 40, 120, 0.12));
      mix-blend-mode: screen;
    }

    body.is-romantic .romantic {
      opacity: 1;
    }

    /* Floating hearts (very lightweight) */
    .hearts {
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 800ms ease;
      overflow: hidden;
    }

    body.is-romantic .hearts {
      opacity: 1;
    }

    .heart {
      position: absolute;
      bottom: -40px;
      font-size: 18px;
      filter: drop-shadow(0 8px 14px rgba(0,0,0,0.25));
      animation: floatUp linear infinite;
      user-select: none;
      will-change: transform, opacity;
      opacity: 0.9;
    }

    @keyframes floatUp {
      0%   { transform: translateY(0) translateX(0) scale(1); opacity: 0.0; }
      10%  { opacity: 0.95; }
      100% { transform: translateY(-110vh) translateX(var(--drift)) scale(1.15); opacity: 0.0; }
    }

    /* =========================
       Layout + Card (Glassmorphism)
       ========================= */
    .stage {
      position: relative;
      height: 100%;
      display: grid;
      place-items: center;
      padding: 24px;
      z-index: 2;
    }

    .card {
      width: min(560px, 94vw);
      border-radius: 22px;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      box-shadow: 0 24px 60px var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      padding: clamp(18px, 3.5vw, 28px);
      position: relative;
    }

    /* Nice top glow */
    .card::before {
      content: "";
      position: absolute;
      inset: -2px;
      border-radius: 22px;
      background: radial-gradient(500px 160px at 20% 0%, rgba(255,255,255,0.18), transparent 55%);
      pointer-events: none;
    }

    .title {
      margin: 0 0 10px;
      font-size: clamp(26px, 4.3vw, 40px);
      letter-spacing: -0.02em;
      line-height: 1.1;
      text-align: center;
      text-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }

    .subtitle {
      margin: 0 0 18px;
      text-align: center;
      color: var(--muted);
      font-size: clamp(14px, 2.2vw, 16px);
      line-height: 1.55;
    }

    /* Message area */
    .message {
      margin: 14px auto 0;
      text-align: center;
      font-size: clamp(16px, 2.6vw, 18px);
      line-height: 1.6;
      padding: 12px 14px;
      border-radius: 14px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.16);
      display: none; /* hidden by default, shown after Yes */
    }

    /* =========================
       Buttons
       ========================= */
    .actions {
      margin-top: 18px;
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }

    button {
      border: 0;
      padding: 12px 18px;
      border-radius: 14px;
      font-weight: 650;
      cursor: pointer;
      transition: transform 180ms ease, box-shadow 180ms ease, background 180ms ease, border-color 180ms ease;
      font-size: 16px;
      user-select: none;
      touch-action: manipulation;
      will-change: transform;
    }

    button:active {
      transform: translateY(1px) scale(0.99);
    }

    .btn-yes {
      background: linear-gradient(135deg, var(--yes), var(--yes2));
      color: white;
      box-shadow: 0 14px 30px rgba(255, 45, 120, 0.35);
    }

    .btn-yes:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 40px rgba(255, 45, 120, 0.45);
    }

    /* The NO button will be positioned by JS */
    .btn-no {
      background: var(--no);
      color: rgba(255,255,255,0.92);
      border: 1px solid var(--no-border);
      box-shadow: 0 14px 30px rgba(0,0,0,0.20);
      position: fixed; /* IMPORTANT: fixed so it can run around anywhere */
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 5;
    }

    .btn-no:hover {
      transform: translate(-50%, -50%) translateY(-1px);
      box-shadow: 0 18px 40px rgba(0,0,0,0.28);
    }

    /* After Yes click, we keep No hidden too via JS */
    .hidden {
      display: none !important;
    }

    /* =========================
       Small footer note
       ========================= */
    .hint {
      margin-top: 14px;
      text-align: center;
      font-size: 13px;
      color: rgba(255,255,255,0.65);
    }
  </style>
</head>

<body>
  <!-- Animated background layers -->
  <div class="bg" aria-hidden="true"></div>
  <div class="romantic" aria-hidden="true"></div>
  <div class="hearts" id="hearts" aria-hidden="true"></div>

  <!-- Main stage -->
  <main class="stage">
    <section class="card" role="dialog" aria-label="Valentine Proposal">
      <h1 class="title">Will you be my Valentine?</h1>
      <p class="subtitle">
        A tiny question with a big heart. üíó <br />
        (Try pressing <b>No üòí</b>‚Ä¶ if you can.)
      </p>

      <div class="actions" id="actions">
        <button class="btn-yes" id="yesBtn" type="button">Yes ‚ù§Ô∏è</button>
        <!-- NO is fixed-position and will be moved by JS -->
      </div>

      <div class="message" id="message" role="status" aria-live="polite"></div>

      <div class="hint">Works on mobile + desktop ‚Ä¢ Smooth animations ‚Ä¢ One-file setup</div>
    </section>
  </main>

  <!-- NO button placed outside card to freely run around viewport -->
  <button class="btn-no" id="noBtn" type="button">No üòí</button>

  <script>
    /**
     * Valentine Proposal ‚Äì Single-file professional implementation
     * Features:
     *  - Animated aesthetic gradient background
     *  - Glassmorphism card UI
     *  - YES click: message + hide buttons + more romantic background + floating hearts
     *  - NO button: smoothly runs away on mouse/touch proximity (desktop + mobile)
     */

    const yesBtn = document.getElementById("yesBtn");
    const noBtn = document.getElementById("noBtn");
    const actions = document.getElementById("actions");
    const message = document.getElementById("message");
    const heartsWrap = document.getElementById("hearts");

    // --- Utility helpers ---
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const rand = (min, max) => Math.random() * (max - min) + min;

    // Track viewport size (responsive)
    let vw = window.innerWidth;
    let vh = window.innerHeight;

    window.addEventListener("resize", () => {
      vw = window.innerWidth;
      vh = window.innerHeight;

      // Keep the NO button within bounds after resize
      const rect = noBtn.getBoundingClientRect();
      moveNoButtonTo(
        clamp(rect.left, 10, vw - rect.width - 10),
        clamp(rect.top, 10, vh - rect.height - 10),
        300
      );
    });

    // =========================
    // YES Button behavior
    // =========================
    yesBtn.addEventListener("click", () => {
      // Show romantic mode background + hearts
      document.body.classList.add("is-romantic");

      // Hide action buttons + NO button
      actions.classList.add("hidden");
      noBtn.classList.add("hidden");

      // Show message
      message.textContent = "Yay! You are my Valentine üíñ‚ú®";
      message.style.display = "block";

      // Start hearts
      spawnHearts();
    });

    // =========================
    // NO Button runaway logic
    // =========================

    /**
     * We move the NO button smoothly by setting left/top and using a CSS transition.
     * On "approach" (mouse moves near it / touch starts), it jumps to a new safe spot.
     */

    // Ensure button has a nice transition for movement
    noBtn.style.transition = "left 420ms cubic-bezier(.2,.9,.2,1), top 420ms cubic-bezier(.2,.9,.2,1), transform 180ms ease";

    // Initial placement: slightly below center so it doesn't overlap card title too much
    placeNoButtonInitial();

    function placeNoButtonInitial() {
      const rect = noBtn.getBoundingClientRect();
      const x = (vw / 2) - (rect.width / 2) + 90;  // offset a bit
      const y = (vh / 2) - (rect.height / 2) + 130;
      moveNoButtonTo(clamp(x, 10, vw - rect.width - 10), clamp(y, 10, vh - rect.height - 10), 0);
    }

    /**
     * Move NO button to a target position in viewport.
     * @param {number} x - left px
     * @param {number} y - top px
     * @param {number} duration - transition duration (ms)
     */
    function moveNoButtonTo(x, y, duration = 420) {
      noBtn.style.transitionDuration = duration + "ms";
      noBtn.style.left = x + "px";
      noBtn.style.top = y + "px";
      // Remove translate centering once we control left/top precisely
      noBtn.style.transform = "translate(0, 0)";
    }

    /**
     * Pick a new random position that:
     *  - stays within viewport bounds
     *  - is not too close to the pointer
     *  - avoids the center card region (roughly) so it doesn't overlap too much
     */
    function getSafeRandomPosition(pointerX, pointerY) {
      const rect = noBtn.getBoundingClientRect();
      const pad = 10;

      const minX = pad;
      const minY = pad;
      const maxX = vw - rect.width - pad;
      const maxY = vh - rect.height - pad;

      // Approx "avoid card area" box (center region)
      const avoid = {
        x1: vw * 0.18,
        y1: vh * 0.18,
        x2: vw * 0.82,
        y2: vh * 0.72,
      };

      let x = 0, y = 0;
      let tries = 0;

      while (tries < 40) {
        x = rand(minX, maxX);
        y = rand(minY, maxY);

        const dx = x - pointerX;
        const dy = y - pointerY;
        const dist = Math.hypot(dx, dy);

        // Keep far enough from pointer for a "running away" feel
        const farEnough = dist > 220;

        // Don't sit inside the center card region too often
        const insideAvoid =
          x > avoid.x1 && x < avoid.x2 &&
          y > avoid.y1 && y < avoid.y2;

        if (farEnough && !insideAvoid) break;
        tries++;
      }

      // Even if not perfect, clamp ensures it's still valid
      return {
        x: clamp(x, minX, maxX),
        y: clamp(y, minY, maxY)
      };
    }

    /**
     * Trigger runaway when pointer is close to the button.
     * This creates a more "realistic" flee behavior vs moving every single time.
     */
    let lastMoveAt = 0;

    function maybeRunAway(pointerX, pointerY) {
      const now = performance.now();
      // Throttle so it doesn't jitter insanely
      if (now - lastMoveAt < 180) return;

      const rect = noBtn.getBoundingClientRect();
      const bx = rect.left + rect.width / 2;
      const by = rect.top + rect.height / 2;

      const dist = Math.hypot(pointerX - bx, pointerY - by);

      // If pointer comes near, escape
      if (dist < 140) {
        lastMoveAt = now;

        const next = getSafeRandomPosition(pointerX, pointerY);

        // Speed feel: farther jump => a bit longer duration
        const jumpDist = Math.hypot(next.x - rect.left, next.y - rect.top);
        const duration = clamp(260 + jumpDist * 0.35, 260, 520);

        moveNoButtonTo(next.x, next.y, duration);
      }
    }

    // Desktop: mousemove detects proximity
    window.addEventListener("mousemove", (e) => {
      if (noBtn.classList.contains("hidden")) return;
      maybeRunAway(e.clientX, e.clientY);
    }, { passive: true });

    // Mobile: touchstart/touchmove detects proximity
    window.addEventListener("touchstart", (e) => {
      if (noBtn.classList.contains("hidden")) return;
      const t = e.touches[0];
      if (!t) return;
      maybeRunAway(t.clientX, t.clientY);
    }, { passive: true });

    window.addEventListener("touchmove", (e) => {
      if (noBtn.classList.contains("hidden")) return;
      const t = e.touches[0];
      if (!t) return;
      maybeRunAway(t.clientX, t.clientY);
    }, { passive: true });

    // If user somehow taps NO, be playful (still runs away)
    noBtn.addEventListener("click", (e) => {
      if (noBtn.classList.contains("hidden")) return;
      const next = getSafeRandomPosition(e.clientX ?? vw/2, e.clientY ?? vh/2);
      moveNoButtonTo(next.x, next.y, 380);
    });

    // =========================
    // Hearts spawner (romantic mode)
    // =========================
    let heartsTimer = null;

    function spawnHearts() {
      // Prevent multiple timers
      if (heartsTimer) return;

      // Create a few immediately
      for (let i = 0; i < 10; i++) createHeart(true);

      heartsTimer = setInterval(() => createHeart(false), 260);
    }

    function createHeart(initialBurst) {
      const heart = document.createElement("div");
      heart.className = "heart";
      heart.textContent = Math.random() < 0.75 ? "üíñ" : (Math.random() < 0.5 ? "üíó" : "‚ú®");

      const size = initialBurst ? rand(16, 26) : rand(14, 24);
      heart.style.fontSize = size + "px";

      const x = rand(0, vw - 20);
      heart.style.left = x + "px";

      // random drift left/right
      heart.style.setProperty("--drift", (rand(-60, 60)) + "px");

      // duration & delay for natural flow
      const duration = initialBurst ? rand(3.2, 5.2) : rand(3.8, 6.4);
      heart.style.animationDuration = duration + "s";

      // small delay sometimes
      if (!initialBurst) heart.style.animationDelay = rand(0, 0.6) + "s";

      heartsWrap.appendChild(heart);

      // Cleanup after animation
      const life = (duration + 0.8) * 1000;
      setTimeout(() => heart.remove(), life);
    }
  </script>
</body>
</html>
